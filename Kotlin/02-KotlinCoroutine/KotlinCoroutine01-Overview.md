# Overview

---

## 1 协程的概念

**维基百科**：

协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。

协程 Coroutines 源自 Simula 和 Modula-2 语言，这个术语早在 1958 年就被 Melvin Edward Conway 发明并用于构建汇编程序，说明协程是一种编程思想，并不局限于特定的语言。

协程的概念应用于多任务调度，相对于多线实现的多任务调度，协程是一种**非抢占式或者说协作式的计算机程序并发调度的实现**。

**子程序**：

子程序即函数，函数调用是通过调用栈来实现的，而栈只有一个入口和一个出口，所以可以认为函数的调用是线性的，调用顺序非常明确。

**协程**：

- 协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。
- 协程存在的意义：**让复杂的异步代码看上去像同步代码，直接自然易懂** 。至于它如何做到这一点，各家的语言实现各有不同。
- 程序可以控制协程的挂起与恢复，而线程则是由操作系统调度的，一般的实现来讲，应用层的线程都会一对一地映射到内核线程，而协程是轻量级的，大量的协程在底层可能只由一个或者接线程来执行。

关于协程概念，具体参考：

- [破解 Kotlin 协程(1) - 入门篇](https://juejin.im/post/5ceb423451882533441ece67#heading-6)
- [协程-维基百科](https://zh.wikipedia.org/wiki/%E5%8D%8F%E7%A8%8B)

---

## 2 kotlin 协程

kotlin 协程的异步需要依赖比它更底层的 API 支持，那么对于 Java 平台上的 Kotlin ，这个所谓的底层 API 就非线程莫属了，所以总的来说，Kotlin 协程的底层是对线程的封装。所以：

- Kotlin 中的协程其实就是一个封装更完备的线程框架，使我们更简单地使用并发功能。
- 相比线程，协程的好处：1 让复杂的并发代码，写起来变得简单且清晰；2 消除了回调，执行耗时任务就像写同步代码一样。

### kotlin 协程概念和作用

一些耗时操作(网络IO、文件IO、CPU/GPU密集型任务)会阻塞线程直到操作完成，Kotlin 的协程提供一种避免阻塞且更廉价可控的操作: `协程挂起(coroutine suspension)`，协程将复杂异步操作放入底层库中，**程序逻辑可顺序表达**，以此简化异步编程，该底层库将用户代码包装为 **回调/订阅** 事件在 **不同线程(甚至不同机器)调度执行**。

### 线程阻塞和协程挂起的区别

- 协程是通过编译技术实现(不需要虚拟机VM/操作系统的支持)，通过插入相关代码来生效， 与之相反，线程/进程是需要虚拟机VM/操作系统OS的支持，通过调度 CPU 执行生效。
- **线程阻塞的代价昂贵**， 尤其在高负载时的可用线程很少，阻塞线程会导致一些重要任务缺少可用线程而被延迟。
- 协程挂起几乎无代价，无需上下文切换或涉及OS， 最重要的是，协程挂起可由用户控制，可决定挂起时发生什么，并根据需求优化/记录日志/拦截，另一个不同之处：**协程不能在随机指令中挂起，只能在挂起点挂起(调用标记函数)**。

### 理解协程

协程函数具有多个入口(每个挂起点)，可以理解为协程把单个协程函数切割成多个独立的代码片段(block) ，这些被切割的函数可以运行在不同的线程，然后利用一个调度机制(比如状态机)控制下一步执行哪个方法，这样就可以在 Java 中实现协程，当然这是编译器的工作，作为协程的使用者对此并无感知。
