# 创建和销毁对象

## 第1条：考虑使用静态工程方法代替构造器

一般情况下创建一个对象，我们都会直接调用其构造方法，但是还有另外一种方法——静态工厂方法(static factory method)，例如下面方法：

```java
public static Boolean valueOf(boolean b){
        return b?Boolean.TRUE:Boolean.FALSE;
}
```

既然标题说考虑使用静态工程方法代替构造器，那么它有什么好处呢？

### 静态工程方法与构造器不同的优势

#### 1，它们有名称

具有适当命名的静态工程方法更易使用，代码也更易阅读。
**当一个类需要多个带有相同签名的构造器时，就使用静态工厂方法代替构造器，并慎重的选择名称以便突出他们之间的的区别**

#### 2，不必在每次调用他们的时候都创建出一个新对象

- 如果需要经常创建相同的对象，并且创建对象的代价很高，可以考虑使用缓存对象，静态方法能够为重复的调用返回相同的对象(实例受控类)
- 单利模式

总而言之，我们可以利用静态方法控制对象的创建

#### 3，它们可以返回原始返回类型的任何子类型的对象

API可以返回对象，同时又不会是使对象的类变成共有的，以这种方式隐藏实现类会使API更加简洁，这项技术适用于基于接口的框架

公共的静态方法所返回的对象的类不仅可以是非共有的，而且该类还可以随着每次调用而发生变化，这取决于静态方法的参数值。从而提高了软件的可维护性和性能，返回的对象也可以随着软件的迭代升级而不同。

**客户端用于不需要知道也不关心他们从静态方法得到的对象的类**。

>比如我们值定义一个接口，而隐藏接口的实现类，在客户端调用我们的静态工厂方法时，我们根据参数返回各种实现的实例对象，从而隐藏了细节，在以后的软件升级中，我们甚至可以删除某些实现类，而客户端永远都不知道。在Android就有许多这样的做法，比如说Window，以及各种系统服务等。

这种灵活的方法构成了访**服务提供者框架**(service provider framework)的基础，如JDBC服务提供者框架有三个重要的组件：

- 服务接口(service interface),用来提供实现者的
- 提供者注册(provider registration api),系统用来注册实现，供客户端访问的
- 服务方法API(service access api)，供客户端获取服务实例

比如下面示例：

```java
public interface Service {
    //在服务接口里面可以定义一些方法
    void send(String msg);
}

/**服务提供接口*/
public interface Provider{

    Service newService();
}


/**不可实例化的class，提供服务端注册与访问*/
public class Services {

    private Services(){};
    /**存储所有服务*/
    private static final Map<String , Provider> mProviders = new ConcurrentHashMap<String, Service.Provider>();

    public static final String DEFAULT_PROVIDER_NAME = "def";

    /**提供注册api*/
    public static void registerDefaultProvider(Provider p){
        registerProvider(DEFAULT_PROVIDER_NAME , p);
    }

    private static void registerProvider(String defaultProviderName, Provider p) {
        mProviders.put(defaultProviderName, p);
    }

    /**service access api*/
    public static Service newInstance(){
        return newInstance(DEFAULT_PROVIDER_NAME);
    }

    private static Service newInstance(String defaultProviderName) {
        Provider p = mProviders.get(defaultProviderName);
        if(p == null){
            throw new IllegalArgumentException("no provider registered with name"+defaultProviderName);
        }
        return p.newService();
    }
}
```

服务端registerDefaultProvider注册服务提供者，客户端调用 service access api —— newInstance 获取服务提供者，进而或许服务对象，而Service的实现细节由服务端实现。

#### 4，在创建参数话类型的时候，它是代码变得更加简洁

当然在jdk1.7这已经不是问题了：

```java
//1.6
Map<String,String> map = new HashMap<String,String>();
//static method
public static <K,V> Map<K,V> newInstance(){
    return new HashMap<K,V>
}

//1.7
Map<String,String> map = new HashMap<>();
```

### 静态工厂方法的缺点

#### 1，如果类不含有公共的受保护的构造器，他们就不能被子类化

解决：考虑使用复合(composition)，而不是继承

#### 2，静态工厂方法看起来与其他静态方法实际上没有任何区别

静态工厂方法一般有如下命名：

- valueOf
- of
- newInstance
- getType
- newType

### 总结

静态过程方法和构造器各有用处，了解它们的长处，但是 **静态方法通常更加适合，因此切忌第一反应就是提供构公共的构造方法而不是考虑使用静态工厂方法**。

## 第2条：遇到多个构造器参数时要考虑使用构造器

构造器和静态方法有一个共同的局限性：它们都不能很好的扩展大量的可选参数。可选方案：

1. 重叠构造器：**重叠构造器模式可行，但是当有许多个参数的时候，客户代码会很难编写，并且仍难以阅读**，所以不推荐
2. JavaBean模式：调用无参数的构造器创建对象，然后通过各种setter方法为每个参数赋值，缺点在于：**因为构造过程被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态**，我的理解是各个参数导致的行为是相互影响的，JavaBean模式不能同时为各个参数赋值。
3. Builder模式：也叫构建者模式，不直接生成想要的对象，而是通过一个Builder对象设置各种可选参数，然后通过Builder的无参方法生成一个不可变对象。如果过多的考虑性能，Builder模式是不错的选择

## 第3条：用私有的构造器或者枚举类型强化 Singleton 属性

- 懒汉式(注意单利引用加上volatile关键字)
- 饿汉式(如果要防止客户端利用反射机制构建第二个对象，可在构造器中判断实例化第二个对象时抛出异常)
- 内部类形式
- 单元素的枚举形式

## 第4条：通过私有构造器强化不可实例化的能力

想Collections，Math等工具类不希望被实例化，实例对其没有任何意义，然而缺少构造器的情况下，编译器会自动为其添加一个公共的无参构造器，通过一些手段可以确保它们不会被实例化：

```java
public class UtilityClass{
    private UtilityClass(){
        throw new AssertionError();
    }
}
```

## 第5条：避免创建不必要的对象

一般来说，最好能重用对象而不是在需要的时候都创建一个相同功能的对象，重用方式快速有方便，如果对象是不可变的，他就始终可以被重用。

一个极端反面的例子：

```java
String s = new String("string");
```

该语句每次执行的时候都会创建一个新的String实例，而

```java
String s = "string";
```

可以保证同一台java虚拟机运行的代码，只要他们包含相同的字符串字面常量，该对象就会被重用

### 1 对于同时提供静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象

```java
        Boolean.valueOf(String);
        //源码如下：
        public static Boolean valueOf(String s) {
        return parseBoolean(s) ? TRUE : FALSE;
        }
```

### 2 除了重用不可变对象外，还可以重用那些已知的不会被改变的可变变对象

```java
class Person {
    private final Date birthDate;

    public Person(Date date) {
        birthDate = date;
    }


    public boolean isBadyBomer() {
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));
        gmtCal.set(1964, Calendar.JANUARY, 1, 0, 0, 0);

        Date boomStart = gmtCal.getTime();

        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        Date boomEnd = gmtCal.getTime();
        return birthDate.compareTo(boomStart) >= 0 && birthDate.compareTo(boomEnd) < 0;
    }
}

// isBadyBomer 中每次都会创建一个Calendar，一个Time.Zone和两个Date实例，如果改成下面方式：

class Person {
    private final Date birthDate;

    public Person(Date date) {
        birthDate = date;
    }

    public static final Date BOOM_START;
    public static final Date BOOM_END;

    static {
        Calendar gmtCal = Calendar.getInstance(TimeZone.getTimeZone("GMT"));

        gmtCal.set(1964, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_START = gmtCal.getTime();

        gmtCal.set(1965, Calendar.JANUARY, 1, 0, 0, 0);
        BOOM_END = gmtCal.getTime();
    }

    public boolean isBadyBomer() {
        return birthDate.compareTo(BOOM_START) >= 0 && birthDate.compareTo(BOOM_END) < 0;
    }
}
```

这样减少了方法每次调用时对象的创建，其次代码变得更加清晰。这里也不建议使用延迟加载(lazily initializing)，这样做会使方法实现更加复杂

### 3 注意 Java1.5 后的自动装箱(autoBoxing)

自动装箱使得基本类型和装箱基本类型(boxed primitive type)可以混用。例如下面代码：

```java
Long sum = 0L;
for (int i = 0; i < Integer.MAX_VALUE; i++) {
    sum += i;
}
```

变量sum被声明为Long而不是long，意味着程序大约构造了2的31方个多余的对象，所以结论是：要优先使用基本类型而不是装箱类型，当心无意识的自动装修

### 总结

1. 不要错误的认为创建对象的代价非常昂贵，我们应该尽可能的避免对象，小对象的创建与回收是非常廉价的，**通过创建附加的对象，提升程序的清晰性，简洁性和功能性，这通常是好事**
2. 反之通过维护自己的对象池来避免创建对象并不是一种好的做法，**除非对象是非常重量级的**

## 第6条：消除过期对象

Java的内存管理相比C/C++更加简单，应为当对象用完后它们会被自动回收，但是支持垃圾回收的语言中，

### 很隐蔽的内存泄漏(无意识的对象保持)

消除过期引用最好的方法就是让包含该引用的变量介绍其生命周期

### 内存泄漏另一个常见的来源是缓存

一旦你把对象引用放入到缓存中，它就很容易被遗忘，这就有可能造成内存泄漏，只要缓存之外存在对某个项的键的引用，该项就有意义，**那么就可以使用WeakHashMap**做缓存，缓存中的项过期后，它们会被自动删除，但是记住：**只有当索要的缓存项的生命周期是有该键的外部引用而不是值决定时，WeakHashMap才有用处**。

LinkedHashMap的removeEldestEntry方法，可以实现在缓存的添加过程中顺便清理不需要的缓存。

```java
public class One_cache {

    public static void main(String[] args) {
        FixSizeLinkedHashMap<String, String> linkedHashMap = new FixSizeLinkedHashMap<>();
        linkedHashMap.setMaxSize(3);
        linkedHashMap.put("aa", "bb");
        linkedHashMap.put("cc", "dd");
        linkedHashMap.put("ee", "ff");
        linkedHashMap.put("hh", "ii");
        linkedHashMap.put("jj", "kk");
        System.out.println(linkedHashMap);
    }

    public static class FixSizeLinkedHashMap<K, V> extends LinkedHashMap<K, V> {

        private int mMaxSize;

        public FixSizeLinkedHashMap() {
            mMaxSize = 10;
        }

        public void setMaxSize(int maxSize) {
            this.mMaxSize = maxSize;
        }

        /**
        * 如果Map的尺寸大于设定的最大长度，返回true，再新加入对象时删除最老的对象
        */
        @Override
        protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
            return size() > mMaxSize;
        }
    }
}

//打印结果是：{ee=ff, hh=ii, jj=kk}
```

### 监听器和回调也是发生内存泄漏常见来源

可以采用 weak reference 保存回调

## 第7条：避免使用终结方法

终结方法(finalizer)通常是不可预测的，也是很危险的，一般情况下是不必要的，使用终结方法会导致行为不稳定，降低性能，以及移植性问题。

终结方法的缺点在于不能保证会被及时的执行，从一个对象变得不可达开始，到它的终结方法被执行，所花费的时间是任意长的，这意味着注重时间的任务不应该由它来完成，例如在终结方法中关闭已打开的文件是严重的错误，打开文件描述符是很有效的资源，由于jvm会延迟执行终结方法，所以大量文件会保留在打开状态。

- **java语言规范甚至不保证终结方法会被执行，所以不应该依赖终结方法来更新重要的持久状态。例如释放共享资源**
- **在正常情况下，没有被捕获的异常将会导致线程的终止，并打印出栈轨迹，但是如果异常发生在终结方法中，则不会，甚至没有任何警告。**

如果要释放资源，可以提供显示的是否资源的方法，如果要使用终结方法，子类在覆盖终结方法时，必须调用父类的终结方法，否则超类的终结方法将永远不会被调用。最好在`finally{}`中调用超类的终结方法。
