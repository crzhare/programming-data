# 类与接口

类和接口是Java程序设计语言的核心，也是Java最基本的抽象单元，在类与接口章节阐述一些知道原则，设计出更加有用，健壮和灵活的类和接口。

## 第13条：使类和成员的可访问性最小化

**要区别设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否可访问其内部数据和其他实现细节。**
设计良好的模块会隐藏所有的实现细节，把他的API与实现细节清晰的隔离出来，然后模块与模块之间只通过他们的API进行通信。这个概念称之为**信息隐藏(information hiding)**或**封装(encapsulation)**

- 有效的接触组成系统的各模块之间的耦合关系(模块可以独立开发，测试，优化，使用，理解，修改)
- 有效的调节性能(模块的优化不影响其他模块)
- 降低构建大型系统的风险(独立模块可用)

所以： **尽可能使每个类或者成员不被外界访问**

### 具体规则

#### 对于顶层的类和接口，只可能有两种访问级别：**包级私有**和**共有的**

- 如果能把类或者接口做出包级私有的，它们就应该是包级私有的，此时它们只是这个包的实现的一部分，而包外无法访问它们，也不知道他们的存在，在之后的迭代中，对它们进行删除，修改，替换，或者删除不会影响包外其他模块
- 如果类和接口被做成公有的，那么开发者有责任用于支持它，以保持兼容性。
- 如果一个包级私有类或接口只是在某一个类的内部被使用， 就应该考虑使它成为使用它的类的私有嵌套类，这样可以进一步缩小它的可访问性。

#### 对于成员（域，方法，嵌套类，嵌套接口）有四种访问级别

- private的，只有类的内部才能访问
- 包级私有的(即没有添加访问修饰关键字，则为缺省(default)的访问级别)
- protected的，同包和子类可以访问
- public的，任何地方都可以访问

当访问级别从包级私有变成受保护级别时，会大大增加可访问性，受包含的成员也代表了改类对某个实现细节的公开承诺，受保护的成员应该尽量少用。

#### 实例域绝不能是共有的

如果一个域是非final的，或者是一个指向可变对象的final应用，一旦它使这个域成为共有的，就意味着**放弃了存储在这个域中的值进行限制的可能性**，当这个域被修改时，你也就失去了对它采取任何行动的能力。**因此：包含共有可变域的类并不是线程安全的**，同时意味着放弃了切换到一种新的内部数据的表示法的灵活性

同样的建议也适用于静态，只用一种列外：**即常量构成了类提供的整个抽象中的一部分，可以通过公有的静态final域来暴露**，同时它应该有以下特点：

- 常量的惯用命名方式
- 这个域包含的是基本数据类型或者引用的是不可变对象

### 示例

类具有共有的静态final数组域，或者返回这种域的方法，这几乎总是错误的。

```java
public static final A[] VALUES = {};

public A[]  getValues() {
    return VALUES;
}
```

如果需要别外界访问，有两种实现方式：

暴露不可变域

```java
private static final A[] PRIVATE_VALUES = {};
//但是返回的不可变列表虽然是只读的，但是对于列表中的单个元素依然是可以被外界修改的。
public static final List<A> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

返回原有域的拷贝。

```java
private static final A[] PRIVATE_VALUES = {};

public static final A[] getValues() {
    return PRIVATE_VALUES.clone();
}
```

## 第14条：在公有类中使用访问方法而非公用域

比如有如下类：

```java
class Point{
    public float x;
    public float y;
}
```

这种类的数据可以被直接访问，无法对数据的改变强加任何约束，当域被访问时，无法采取任何辅助行为，**坚持面向对象程序设计的程序员应该对这种类深恶痛绝**，所以我们应该提供访问域的方法：

```java
class Point{
    private float x;
    private float y;

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }
}
```

坚持面向对象程序设计思想的看法是：

- 如果类可以在它所在包外部进行访问，就提供方法，以保留将来改变该类的内部表示非的灵活性，如果共有泪暴露了它的数据域，要想在将来改变其内部表示发誓不可能的，因为公有类的客户端代码已经遍布各处了然而，
- 如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误。
- 总之：共有类永远都不应该暴露可变的域。

## 第15条：使可变性最小化

不可变类只是一个实例不能给修改的类，在每个对象创建的时候，所有的信息都要提供，信息一旦确定，在对象的真个生命周期都不可改变，java中有很多的不可变类：String,基本数据类型包装类，BigInteger，BigDecimal，不可变类有如下优点：更加易于设计，实现和使用，不容易出错，更加安全

使类成为不可变类要遵守以下规则：

- 不要提供人任何修改对象状态的方法
- 保证类不可被拓展，比如final类
- 使所有域都是final的
- 使所有域都变成私有的
- 确保对于任何可变组件的互斥访问。永远不要用客户端提供的对象来初始化对象的私有可变域，使用保护性拷贝。

### 不可变象的好处

不可变对象本质上是线程安全的，他们不需要同步。
不可变对象可以被自由的共享。
推荐使用静态final常量表示频繁用到的不可不对象。
不可变对象不仅可以被共享，甚至可以共享他们的内部信息

**不可变象真正唯一的缺点是，对于每一个值都需要一个单独的对象**。

### 技巧

如果需要执行一个多步骤的操作，且每一个操作都会产生一个新的对象，但是只有最后的结果对象才被需要，这样会有性能问题，解决方法是提供一个**可变配套类**，如String对应的StringBuilder。

一种更加灵活的让不可变类变成final的办法是，让类的所有构造器变为私有的或者包级私有的，并添加静态工厂方法代替共有的构造器。这样不可变类便有了对象缓存能力。

### 注意

如果选择让不可变类实现Serializable接口，并且包含多个可变对象域，就必须显示的提供readObject和readResolve方法，

总之：坚决不要给每一个get方法编写一个对应的set方法，除非有很好的理由，要让类变成可变类，否则就应该是不可变的，如果类不能做到不可变的，仍然应该尽可能的控制它的可变性，**降低对象可以存在的状态数，可以更容易分析对象的行为**

## 第16条：复合优先于继承

继承(inheritance)是实现代码重用的重要手段，但是使用不当，会导致软件变得很脆弱。在包类使用继承是非常安全的，这里的类都处于同一个程序员控制之下，然而对于普通的类进行跨包边界进行继承是非常危险的，

与方法调用不同的是，继承打破了封装性，子类依赖于超类中特定功能的实现细节，但是超类的实现可能随着版本发行而改变，如果真的改变了，那么子类可能遭到破坏，即使它的代码完全没有改变。

总之就不受控的情况下，超类随着发行版本的某些实现改变，对给子类的危险是不可预知的。

### 使用复合(composition)

不扩展现有的类，而是在新的类中增加一个私有域，它引用现有类的一个实例，这种设计承做复合。
在新的类中每个实例方法都可以调用被包含的现有类实例中对应的方法，并返回它的结果，这称之为**转发**。这样得到的类将更加稳固。它不依赖于现有类的实现细节，即使现有类添加了新的方法，也不会影响新的类。

>这也应该是一种包装设计模式，在java Api中就有很多的体现，比如Java中的IO大量使用了包装设计模式，而不是继承。

```java
public class FilterInputStream extends InputStream {
    protected FilterInputStream(InputStream in) {
        this.in = in;
    }
    ......
}
```

实现这种模式通常的步骤是：

1. 实现被包装类的共有接口
2. 在构造方法声明共有接口，以此来注入被包装类
3. 实现方法时，调用被保证类对于的方法

接口给复合带来了格外的灵活性，通过接口，我们可以包装任何接口的实现。

**总结**：只有当子类真正是超类的子类型时，才适合继承，在决定使用继承而不是复合之前，还需要考虑被扩展的类的API是否有缺陷，继承机制会把超类所有的API的缺陷传播到子类中，而复合则允许设计新的API来隐藏这些缺陷。继承很强大，但是它违背了封装的原则，包装类不仅比子类更加健壮，而且功能更加强大。

## 第17条：要么为继承而设计，并提供文档说明，要么就禁止继承

随意的基层某个没有文档说明的类是非常危险地，所以要么为继承而设计，并提供文档说明，要么就禁止继承，那么对于专门为了继承而设计的类并具有良好的说明文档的类而言，有意味着什么呢？

首先**类的文档必须精确的描述覆盖每个方法所带来的影响**，关于程序文档有句格言**好的文档应该描述一个给定的方法做了什么工作，而不是描述它是如何做到的**

为了使程序员能够编写出更加有效的子类，而无需承受不必要的痛苦，类必须通过某种形式提供适当的钩子(hook)，以便能够进入到他的内部工作流程中，这种形式可以是精心选择的protected方法或者是protected的域。

对于为了继承而设计的类，唯一的测试方法就是编写子类。3个子类通常足以测试一个可扩展的类。

为了允许继承，类还必须遵守其他的一些约束，构造器绝不能调用可被覆盖的方法。无论是直接的还是间接的。

为了继承而设计类的时候，Cloneable和Serializable接口出现了特殊的困难，因为clone和readObject方法在行为试试哪个非常类似与构造器，所以**都不可以调用构造可覆盖的方法，无论直接还是间接的**

如果决定在一个为了继承而设计的类中实现Serializable，并且该类有一个readResolev或者writeReplace方法，就必须使readResolve或者writeReplace成为受保护的方法。如果是私有的，子类将会不声不响的忽略掉这两个方法。

总结：**对于那些并非为了安全的进行子类化而设计的和编写文档的类，要禁止子类化**，有两种方法，一种是生命类为final的，还有一种是私有化类的构造方法(或者包级私有的)，，并提供共有的静态方法类代替构造器。

## 第18条：接口优于抽象类

Java语言提供了两种机制，可以用来定义允许多个实现的类型：接口和抽象类。他们之间的区别为：抽象类允许包含某些方法，但是接口则不允许，一个更重要的区别在于，为了实现抽象类定义的类型，类必须成为这个抽象类的子类，而任何一个类只要定了所需要的方法，遵守通用的约定，就允许实现一个接口。**因为Java只允许单继承，所以抽象类作为类型定义受到了极大的限制**

### 现有类可以很容易被更新，以实现新的接口

我们只需要添加必要的方法，就可以轻易的实现一个接口，然而，一般来说**无法更新现有的类来扩展新的抽象类**，除非让现有类的祖先成为新的抽象类的子类，但是这种伤害是非常大的。

### 接口是定义mixin(混合类型)的理想选择

mixin类型：类除了实现它的基本类型之外，还可以实现mixin类型，以表明某些可供选择的行为，例如实现了Comparable接口，就表明了该类的实例可以与其他的可比较对象进行排序。这样的接口称之为mixin接口，因为它允许任选的功能可以被混合到类型的主要功能中。而抽象类无法用于定义mixin。

### 接口允许我们构造非层次结构的类型框架

类型层次对于组织某些事物是非常合适的，但是其他有些事务不能被整齐的组织成一个严格的层次结构。

```java
//歌唱家
public interface Singer{

}
//作曲家
public Songwriter{

}
```

例如上面两个接口分别代表一个歌唱家，一个作曲家。在现实生活中，有些歌手本身也是作曲家，因为我们使用了接口来定义这两种类型，而不是抽象类，所以对单个类而言，同时实现两个接口是完全允许的。获取我们还可以定义第三个接口：

```java
public interface SingerSongwriter extends Singer,Songwriter{

}
```

获取比并不需要这种灵活性，但是一旦你这样做了，接口可以成为救世主。对于共性的抽象和功能的拓展一定要分清，在包装类模式中，使用接口使得安全的增强类的功能成为可能。

### 为接口提供骨架实现

虽然接口不允许包含方法的实现，但是，使用接口定义类型并不乏妨碍你为程序员提供实现上的帮助，对每个公共的接口都提供一个抽象的骨架实现(skeletal implementation)类，把接口和抽象类的有点结合起来，**接口的作用仍然是定义类型，而骨架实现掌管了所有所有接口实现有关的工作**。

例如下面例子：

```java
//java.util.Collections
public static <T> Collection<T> synchronizedCollection(Collection<T> c) {
        return new SynchronizedCollection<>(c);
    }

static class SynchronizedCollection<E> implements Collection<E>, Serializable {
......
}
```

在Collections中提供了把不安全的基本转变为线程安全的集合方法，充分的展示了骨架实现的强大功能。骨架实现的美妙至于在于，它们为抽象类提供了实现上的帮助，又不强加抽象类被用作类型定义时所特有的严格限制。

骨架实现类可以很好的帮助接口的实现，实现了这个接口的类，可以把对于某一个接口方法的调用，转发到一个内部私有类的实例上，这个内部私有类扩展了骨架实现类，这种方法称为**模拟多次继承**，这项技术具有多重继承的绝大多数优点，同时又避免了响应的缺陷。

**如何编写抽象类**：首先必须认真研究接口，并确定哪些方法是最基本的(primitive),其他方法则可以根据它们来实现，这些方法将成为接口中的抽象方法，然后骨架实现必须为借口中所有其他的方法提供具体的实现，

### 抽象类的演变比接口的演变要容易的多

如果在后续的发行版中中，希望在抽象类中增加新的方法始终可以增加具体的方法，然而接口是行不通的。虽然可以在接口的骨架实现中增加默认方法，但是不从骨架实现继承的接口实现还是会遭到破坏。因此：接口一旦被公开发行，并且被广泛的实现，要想再改变这个接口几乎是不可能的。

总结：**接口通常是定义允许多个实现的类型的最佳途径，但是规则有一个例外，即当演变的容易性要灵活性和功能更加重要的时候。**

## 第19条：接口只用于定义类型

当类实现接口时，接口就充当可以引用这个类的实例的类型。因此类实现了某一个接口，就表明客户端可以对这个类的实例实施某些操作，为了任何其他目的而定义接口是不恰当的。

**避免使用常量接口**，如果要使用常量，有以下合理的方法：

- 如果这个常量与某个现有类或接口相关，应该把常量定义在这个类或者接口中。
- 如果这些常量最好被看做枚举，就使用枚举定义
- 应该使用不可实例化的工具类来导出常量

总而言之，接口只应该用来定义类型，不应该用来导出常量。

## 第20条：类层次优先于标签类

有时候，可能会遇到带有两种风格甚至更多风格的实例的类，并包含表示实例风格的标签(tag)域，例如下面一个类，能表示圆形或者方形：

```java
public class Figure {

    enum Shape {
        rectangle, circle
    }

    final Shape shape;

    double radius;

    double height;
    double width;

    Figure(double radius) {
        shape = Shape.circle;
        this.radius = radius;
    }

    Figure(double width, double height) {
        shape = Shape.rectangle;
        this.height = height;
        this.width = width;
    }

    double area() {
        double area = 0;
        switch (shape) {
            case circle:
                area = height * width;
                break;
            case rectangle:
                area = Math.PI * (radius * radius);
                break;
        }
        return area;
    }

}
```

这种标签类有着许多的缺点，充斥着样板代码，内存占用，如果要增加标签，又要写很多条件语句，所以我们应该使用**子类型化**，标签类正是类层次的一种简单效仿，将标签类转变为层次类，抽取共性行为，这里只有area。

```java
public abstract class Figure {

    public abstract  double area();

}

class Circle extends Figure{

    private final double radius;
    @Override
    public double area() {
        return  Math.PI * (radius * radius);
    }

    Circle(double radius) {
        this.radius = radius;
    }
}

class Rectangle extends Figure{

    private final double width;
    private final double height;

    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }

    @Override
    public double area() {
        return  height * width;;
    }
}
```

这种类层次纠正了标签类的所有缺点，代码简单而且清晰。没有多个构造器的影响，每个域都可以定义为为final的，没有了switch语句，而且更加易于拓展，类层次的另一个好处在于：他们可以反应类型之间本质上的层次关系。

```java
public Square extends Rectangle{
...
}
```

简而言之：标签类很少有适用的时候。

## 第21条：用函数对象表示策略

在TreeSet创建时我们可以传入一个比较器：

```java
//构造一个新的空 TreeSet，它根据指定比较器进行排序。
TreeSet(Comparator<? super E> comparator)
```

TreeSet会根据比较器实现的不同而对存入元素进行不同的排序，这正是策略(strategy)模式的一个例子，一般在java中实现策略模式，首先声明一个接口来表示该策略，并且为每个具体的策略声明一个实现了接口的类。

## 第22条：优先考虑静态成员类

嵌套(nested)是指被定义在另一个类的内部的类，嵌套类存在的目的应该只是为了他的外围(enclosing)提供服务，如果嵌套类可能用于其他的某个环境中，他就应该是顶层类(top_level)，嵌套类有四种：

- 静态成员类(static member)
- 非静态成员类(nostatic member)
- 匿名类(anonymous)
- 局部类(local)

静态成员类是最简单的一种类，静态成员类的一种常见用法是作为共有的辅助类，仅当它与外部类一起使用才有意义。

非静态成员类和静态成员类的区别：

- 非静态成员类都隐含着与外围类的一个实例相关联，非静态成员类可以调用外围泪的方法，访问外围类的成员，利用修饰过的this可以获取外围类的实例引用(Android中常因此而发生内存泄漏)
- 如果一个嵌套成员类要独立于外围类的实例而存在，那么这个嵌套成员类必须是静态的。非静态成员类不可能独立于它的外围类的实例而独立存在。

非静态成员类与他的外围类的关系的创建都是需要时间开销的。并且消耗非静态成员类实例的空间，如果声明成员类不要求访问外围实例，就始终要它定义为静态的。匿名类只有出现在非静态的环境中才有他外围类的实例，匿名类不应该过长，10或者更少为好，一般用于动态的创建函数对象。局部类用的比较少，规则与匿名类一样。
