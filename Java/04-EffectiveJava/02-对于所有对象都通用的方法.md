# 对于所有对象都通用的方法1

尽管 Object 是一个具体的类，但是它的设计主要是为了扩展，它所有的非 final 方法如下:

- equals
- hashCode
- toString
- clone
- finalize

这些方法都有明确的通用约定(general cantract)

## 第8条 覆盖equals方法时请遵守通用约定

在不覆盖 equals 方法时，类的所有实例只与它自身相等。

以下情况不用覆盖equeal方法：

- 类的每个实例本质上都是唯一的，例如：Thread。
- 不关心类是否提供了“逻辑相等(logical equality)”的测试功能，例如：Random实现了equals方法用于判断两个Random产生的随机数是否相同，但是设计者并不认为客户端需要或者期望这样的功能，这样的情况下继承Object的equals方法以及足够满足需求。
- 超类覆盖了equals方法，从超类继承过来的行为对于子类是适合的。
- 类是私有的或者包级私有的，可以保证它的equal方法永远不会被调用。
- **值类**不需要覆盖equals方法，即每个值之所存在一个对象。

**如果类具有自己特有的逻辑相等概念，而且超类还没有覆盖equals已实现所期望的行为**，这个时候我们应该实现equals方法。

下面是实现equals的通用规范

- **自反性**——reflexive：对于任何非null的引用值x，x.equals(x)必须返回true
- **对称性**——symmetric：对于任何非null的引用值x和y，当且仅当y.equals(x)返回true时，x.equals(y)才返回true
- **传递性**——transitive：对于任何非null的引用值x,y,z,如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)也必须返回ture
- **一致性**——consistent：对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)必须一致的返回相同的结果
- 对于任何非null的值引用x,x.equals(null)必须返回false

如何高质量的实现equals方法：

1. 优先使用==操作符检查参数是否为这个对象的引用，如果是直接返回true，只是一种性能优化。
2. 使用instanceof操作检查参数类型。
3. 把参数转换成正确的类型。
4. 对于该类中的每个**关键**域，检查参数中的域是否与该对象中对于的域相等。
5. 编写完成queals方法后，应该问自己，它是是否对称的，传递的，一致的？
6. 覆盖equals方法时总要覆盖hashCode方法。
7. 不要使equals方法过于智能。
8. 不要将equals方法声明的Object参数替换成其他类型(实际上这已经不是覆盖了)。

如下面示例：

```java
public static class PhoneNumber {

    private final int areaCode;
    private final int prefix;
    private final int lineNumber;

    public PhoneNumber(int areaCode, int prefix, int lineNumber) {
        this.areaCode = areaCode;
        this.prefix = prefix;
        this.lineNumber = lineNumber;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == this) {
            return true;
        }
        if (!(obj instanceof PhoneNumber)) {
            return false;
        }
        PhoneNumber phoneNumber = (PhoneNumber) obj;
        return phoneNumber.areaCode == areaCode && phoneNumber.prefix == prefix && phoneNumber.lineNumber == lineNumber;
    }

}
```

具体可参考《EffectiveJava》

## 第9条：覆盖equals时总要覆盖hashCode

覆盖equals时总要覆盖hashCode，如果不这么做的话，就违反了Object.hashCode的通用规定，从而导致该类无法结合**所有基于散列的集合**一起正常工作，这样的集合包括HashMap，HashSet和HashTable。

hashCode有以下约定：

- 在应用程序的执行期间，只要对象的equals方法的比较操作所用的信息没有被修改，那么对这个对象调用多次hashCode方法，都必须始终返回相同的整数（在同一个应用程序多次执行的过程中，可以不一致）。
- 如果两个对象根据equals方法比较是相等的，那么调用两个对象任意一个的hashCode方法都必须产生同样的整数结果
- 如果两个对象根据equals方法比较是不相等的，那么调用两个对象任意一个的hashCode方法则不一定要产生不同的整数结果

>但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表(hash table)的性能

对于第八条给出的例子 PhoneNumber：

```java
HashMap<PhoneNumber, String> hashMap = new HashMap<>();
hashMap.put(new PhoneNumber(204, 132, 255), "ztiany");

String s = hashMap.get(new PhoneNumber(204, 132, 255));
// 打印结果：null
System.out.print(s);
```

由于PhoneNumber没有覆盖hashCode方法，导致根据相同的电话号码回去已存入的联系人却返回null。

所以只需要覆盖hashCode方法即可：

```java
@Override
public int hashCode() {
    return 42;
}
```

这时我们就可以获取到字符串"ztiany"了。

但是这样覆盖hashCode方法是非常恶劣的，它使每个对象都具有了相同的散列码，因此每个对象都被映射到相同的散列桶中，使散列表退化成链表结构。

一个好的散列表函数通常倾向于“为不同的对象产生不相等的散列码”。**理想情况下应该把集合中不相等的实均匀的分不到所有可能的散列值上**，要达到这种理想的情形很困难，但是接近这种理想的情形则并不困难，下面是一种简单的解决办法：

1. 把某一个非0常整数，比如17，保存作为一个result的int类型的变量中
2. 对于对象中每个关键域f(equals中涉及的每个域)，完成以下步骤：
   - 如果是boolean类型：计算：f?1:0
   - 如果是byte，char，short或者int类型，计算：(int)f
   - 如果是long类型，则计算:(int)(f^(f>>>32));
   - 如果是flat类型，则计算:Float.floatToIntBits(f);
   - 如果是double类型，计算：Doul,doubleToLongBits(f);
   - 如果是对象引用，并且该类的equals方法通过递归的调用equals方法来比较这个域，则同样为这个域递归的调用hashCode
   - 如果是数组，Arrays.HashCode
   - 最后按照下面公式合并上述规则计算的结果c合并到result中：`resut = 31*result+c;`
3. 返回result
4. 编写单元测试，验证

比如多上面PhoneNumber可以实现如下hashCode方法：

```java
@Override
public int hashCode() {
    int result = 17;
    result  = 31 *result + areaCode;
    result  = 31 *result + prefix;
    result  = 31 *result + lineNumber;
    System.out.println(result);
    return result;
}
```

## 第10条：始终要覆盖toString

覆盖toString方法，并且准守一定的规则，可以让类用起来更加舒适，在打印对象的时候，打印的结果更加直观和有意义。

## 第11条：谨慎的覆盖clone

实现Cloneable接口，表明对象是可以被克隆的，它决定Object中受保护方法cloen实现的行为，如果实现了Cloneable，Object的clone方法返回该对象的逐域拷贝，否则抛出CloneNotSupportException异常。标记接口是接口的极端用法，不值得效仿。

### 规范

**clone方法不会调用对象的构造方法**，clone方法返回一个该对象的拷贝，这个拷贝的精确含义取决于该对象的类，一般含义是：

```java
    对于任意的对象x，表示式：
       x.clone() != x;
    将会是true，并且表达式
       x.clone().getCass() == x.getClass()
    将会是ture，但是这都不是绝对的，虽然通常情况下，表达式
       x.clone().equals(x)
    将会是true，但是也不是绝对的
```

**对于clone方法：如果你覆盖了非final类中的clone方法，则应该返回一个通过调用super.clone而得到的对象**，如果所有超类都这么做，那么调用super.clone方法最终会调用Object.clone方法，从而创建出正确的实例，这种机制大体上类似于自动的构造器调用链，只不过他不是强制要求的。

从super.clone()中得到的对象可能接近于最重要返回的对象，也可能相差甚远，这取决于这个类的本质。

### 示例

如果对象的每个域包含一个基本类型的值，或者包含一个指向不可变对象的引用，那么返回的对象则可能正式你所需要的对象，这种情况不需要再做处理，如前面章节的示例PhoneNumber：

```java
    @Override
    public PhoneNumber clone() {
        try {
            return (PhoneNumber) super.clone();
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
            throw new AssertionError();//不会发生
        }
    }
```

>clone返回的类型是PhoneNumber，而不是Object，从Java1.5开始这么做是合法的。

如果对象中包含的域引用了可变对象，使用上面简单的clone方法可能造成灾难性的结果，如下Stack类：

```java
public static class Stack implements Cloneable {
        private Object[] objects;
        private int size;
        public static final int DEFAULT_SIZE = 16;

        public Stack() {
            objects = new Object[DEFAULT_SIZE];
        }


        public void push(Object o) {
            ensureCapacity();
            objects[size++] = o;
        }

        public Object pop() {
            if (size == 0) {
                throw new EmptyStackException();
            }
            Object o = objects[--size];
            objects[size] = null;
            return o;
        }

        private void ensureCapacity() {
            if (size == objects.length) {
                objects = Arrays.copyOf(objects, 2 * size + 1);
            }
        }

        //just for test
        public Object get() {
            return objects;
        }

        @Override
        public Stack clone() {
            try {
                return (Stack) super.clone();
            } catch (CloneNotSupportedException e) {
                e.printStackTrace();
                throw new AssertionError();
            }
        }
    }
```

我们在客户端调用：

```java
            Stack stack = new Stack();
            stack.push(12);
            Stack stack1 = stack.clone();
            System.out.println(stack.get() == stack1.get());
```

结果是true，这表明被clone的Stack1对于所引用的objects与原Stack所引用的objects是相同的数据实例，修改原始实例会破坏被克隆对象中的约束条件，反之亦然。

实际上clone方法就是另一个构造器，必须确保它不会伤害到原始的对象，并确保正确的创建被克隆，为了使Stack能够正常工作，它必须要拷贝栈的内部信息。如：

```java
            @Override
            public Stack clone() {
                try {
                    Stack result =  (Stack) super.clone();
                    result.objects = objects.clone();
                    return result;
                } catch (CloneNotSupportedException e) {
                    e.printStackTrace();
                    throw new AssertionError();
                }
            }
```

同时我们还需要注意，如果elements域是final的，上面方案就不能正常工作，因为clone方法是禁止给final域赋新值的，**clone框架与引用可比变对象的fianl域的正常用法是不相兼容的**，除非原始对象可与被克隆对象之间安全的共享此可变对象。为了使类成为可以克隆的，可能有必要从某些域中去掉final修饰符。

但是对付更加复杂的对象上面方式实现的clone方法可能还不够，比如HashTable这样的类：

```java
public static class HashTable implements Cloneable{

    private Entry[] buckets = ...;

    private static class Entry{

        final Object key;
        Object value;
        Entry next;

        public Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
}
```

虽然被克隆的对象有它自己的散列桶数组，但是**这个数组引用的链表与原始的对象是一样的**，从而很容易引起克隆对象和原始对象的不确定行为。为了修复这个问题，我们必须单独的拷贝并组成每个桶的链表。如：

```java
public static class HashTable implements Cloneable {

    private Entry[] buckets =  ...;

    @Override
    protected HashTable clone() {
        try {
            HashTable result = (HashTable) super.clone();
            result.buckets = new Entry[buckets.length];
            int length = buckets.length;
            for (int i = 0; i < length; i++) {
                if (buckets[i] != null) {
                    result.buckets[i] = buckets[i].deepCopy();
                }
            }
            return result;
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }

    private static class Entry {
        final Object key;
        Object value;
        Entry next;

        Entry deepCopy() {
            return new Entry(key, value, next == null ? null : next.deepCopy());
        }

        public Entry(Object key, Object value, Entry next) {
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
}
```

或者为了防止递归造成的栈溢出，深度拷贝用如下实现：

```java
     Entry deepCopy2() {
        Entry result = new Entry(key, value, next);
        for (Entry p = result; p.next != null ; p=p.next) {
            p.next = new Entry(p.next.key, p.next.value, p.next.next);
        }
        return result;
    }
```

### 建议

- clone方法不应该在 构造过程中，调用新对象中任何非final的方法，如果clone调用了一个被覆盖的方法，可能导致克隆对象和原始克隆对象之间的不一致。
- 覆盖clone方法应该内部处理CloneNotSupportException，而且不会发生类型转换异常，如果类是专门为了继承而设计的，它应该声明clone方法为protected的，并且模拟抛出异常
- 如果决定用线程安全的类实现Cloneable接口，记得它的clone方法也做好同步

简而言之：所有实现了Cloneable接口的类都应该用一个共有的方法覆盖clone，此方法首先调用super.clone(),然后修正任何需要修正的域。这意味着要拷贝任何包含内部“深层结构”的可变对象。
更多细节可以参考《EffectiveJava》

### 另外一种实现：拷贝构造器

如果一个对象太过于复杂，可以考虑采用其他方式实现对象拷贝，如提供一个拷贝构造器，它唯一的参数就是包含该构造器的类。如：

```java
public A(A a){
    A copyA = new A();
    ...
    return coayA;
}
```

拷贝构造器与静态工厂方法的变形，都比Cloneable/clone方具有更多的优势，它们不依赖于很有风险的语言之外的对象创建机制，不需要遵守某些规范....。

更进一步，拷贝构造器或者拷贝工厂可以带有一个参数，参数类型是通过该类实现的接口，由此可以实现转换构造器：

```java
public HashMap newHashMap(Map map){
    ....
}

public TreeSet newTreeSet(Set set){
    ...
}
```

**既然Cloneable有这么多问题，可以肯定的说，其他接口都不应该扩展这个接口，为了继承而设计的类也不应该实现这个接口**，甚至有很多专家程序员从来不覆盖clone方法，也从来不用，除非是数组拷贝。

## 第12条：考虑实现Comparable接口

compareTo方法并没有在Object中声明，相反，它是Comparable接口中唯一的方法，comparaeTo方法不但允许简单的等同性比较，而且允许执行顺序比较，实现了Comparable接口，就表明它的实例具有内在的排序关系(natural ordering).为实现Comparable接口的对象数据排序就这么简单：

```java
Arrays.sort(a)
```

对集合中的Comparable对象进行搜索，计算极限值以及自动维护也同样简单。一如下面程序依赖String实现了Comparable接口，去掉了命令行参数列表中的重复参数。并按字母顺序打出来

```java
public static void main(String[] args) {
    Set<String> strings = new TreeSet<>();
    for (int i = 0; i < 100; i++) {
        strings.add(String.valueOf(i % 5));
    }
    // 打印结果：[0, 1, 2, 3, 4]
    System.out.println(strings);
}
```

Java平台的所有值类(values classes)都实现了Comparable接口，如果你正在编写一个值类，它具有非常明显的内在排序关系，比如按字母排序，按数字排序...。，那几应该坚决的考虑实现这个接口：

```java
public interface Comparable<T>{
    int compareTo(T t);
}
```

compareTo方法的通用约定与equals方法相似：将这个对象与指定对象进行比较，当该对象小于，等于，或者大于指定的对象时候，分别返回一个负整数，零或者正数，如果由于指定的对象的类型而无法与该对象进行比较，那么抛出ClassCastException异常

>sgn函数说明，它根据表达式的值为负数，零，正数分别返回-1，0，1；

实现者必须确保所有的x和y都满足

- `sgn(x.compareTo(y) == -y.compareTo(x))`。
- `x.compareTo(y) > 0 && y.compareTo(z) > 0 那么x.compareTo(z)必然大于0`
- `x.compareTo(y)==0`暗示着所有的z都满足`sgn（x.compareTo(z)) == sgn(y.compareTo(z))`
- 强烈建议`x.compareTo(y)==0 == (x.equals(y))`但这并非绝对必要。一般来说实现了Comparable接口的类，若是违反了这个条件，都应该予以说明

最后一个约定是一个强烈的建议，而不是真的规则：

**例如BigDecimal类，他的compareTo方法与equals不一致**。

```java
public static void main(String[] args) {
    BigDecimal decimal = new BigDecimal("1.332");
    BigDecimal decimal1 = new BigDecimal("1.3320");

    HashSet<BigDecimal> bigDecimals = new HashSet<>();
    bigDecimals.add(decimal);
    bigDecimals.add(decimal1);
    System.out.println(bigDecimals.size());


    TreeSet<BigDecimal> treeSet = new TreeSet<>();
    treeSet.add(decimal);
    treeSet.add(decimal1);
    System.out.println(treeSet.size());
}

// 打印结果为： 2 1
```

与Comparable相关的，还有一个Comparator 接口具有类似的功能。
