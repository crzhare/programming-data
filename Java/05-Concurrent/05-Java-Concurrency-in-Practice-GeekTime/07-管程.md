# 管程

>管程 (英语：Monitors，也称为监视器) 是一种程序结构，结构内的多个子程序（对象或模块）形成的多个工作线程互斥访问共享资源。这些共享资源一般是硬件或一群变量。管程实现了在一个时间点，最多只有一个线程在执行管程的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程实现很大程度上简化了程序设计。管程提供了一种机制，线程可以临时放弃互斥访问，等待某些条件得到满足后，重新获得执行权恢复它的互斥访问。<br/>
>管程是东尼·霍尔与泊·派克·汉森提出的，并由泊·派克·汉森首次在并行Pascal中实现。——[《维基百科》](https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_(%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96))

- Java 语言在 1.5 之前，提供的唯一的并发原语就是管程，而且 1.5 之后提供的 SDK 并发包，也是以管程技术为基础的。
- C/C++、C# 等高级语言也都支持管程。
- 可以说管程就是一把解决并发问题的万能钥匙。

## 1 什么是管程

管程，指的是**管理共享变量以及对共享变量的操作过程，让它们支持并发**。在 Java 中的体现，就是管理类的成员变量和成员方法，让这个类是线程安全的。

### Java 为什么选择管程

Java 语言在 1.5 之前，提供的唯一的并发原语就是管程，这体现在 `synchronized` 关键字及 `wait()、notify()、notifyAll()` 中，它们都是管程模型的组成部分，所以 Object 上的这些方法并不是凭空产生的。

操作系统原理课程告诉我们，用信号量能解决所有并发问题，Java 采用的却是管程技术，为什么呢？其实管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程更容易使用（即`synchronized/wait/notify`系列方法），所以 Java 选择了管程。

### 管程的名称

管程，对应的英文是 Monitor，很多 Java 领域的同学都喜欢将其翻译成“监视器”，这是直译。操作系统领域一般都翻译成“管程”，这个是意译。

### 管程的模型

在管程的发展史上，先后出现过三种不同的管程模型，分别是：

- Hasen(汉森) 模型
- Hoare(霍尔) 模型
- MESA 模型

现在广泛应用的是 MESA 模型，并且 Java 管程的实现参考的也是 MESA 模型。

## 2 MESA 模型

### 并发编程的两大核心问题：互斥与同步

在并发编程领域，有两大核心问题：一个是互斥，即同一时刻只允许一个线程访问共享资源；另一个是同步，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。

### 管程如何解决互斥问题

管程解决互斥问题的思路很简单，就是**将共享变量及其对共享变量的操作统一封装起来**。比如封装一个队列，只提供 `enq()`和 `dep()` 两个方法，只有进入管程才能调用这些方法，且同一时刻，只能有一个线程能进入管程。

```java
//进入管程
monitor{
    //队列
    var queue;
    //入队
    func enq()；
    //出队
    func dep();
}
```

线程 A 和线程 B 如果想访问共享变量 queue，只能通过调用管程提供的 `enq()`、`deq()` 方法来实现；`enq()`、`deq()` 保证互斥性，只允许一个线程进入管程。

### 管程如何解决同步问题

**同步即线程之间如何通信、协作**， MESA 管程模型引入了等待队列和条件变量，使线程之间可以相互等待和通知，即 `wait()、notify()、notifyAll()` 等方法。

- 在进入管程之前有一个等待队列。
- 每个条件变量都对应有一个等待队列。
- 当线程离开管程是通知入口的等待队列。
- 当某个线程使某个条件满足时，通知在该条件变量对于的等待队列上的线程。

下面这张图很好的体现了线程之间如何通信、协作。

![07_monitor_sync](images/07_monitor_sync.png)

>这里注意，wait 是会释放锁的，所以线程被唤醒后需要重新进入入口队列。

#### `wait()` 的正确姿势

对于 MESA 管程来说，有一个编程范式，就是需要在一个 while 循环里面调用 `wait()`。这个是 MESA 管程特有的。

```java
while(条件不满足) {
  wait();
}
```

具体原因如下：Hasen 模型、Hoare 模型和 MESA 模型的一个核心区别就是当条件满足后，如何通知相关线程。

管程要求同一时刻只允许一个线程执行，那当线程 T2 的操作使线程 T1 等待的条件满足时，T1 和 T2 究竟谁可以执行？

- Hasen 模型里面，**要求 `notify()` 放在代码的最后**，这样 T2 通知完 T1 后，T2 就结束了，然后 T1 再执行，这样就能保证同一时刻只有一个线程执行。这样在代码编写上就不够灵活。
- Hoare 模型里面，T2 通知完 T1 后，T2 阻塞，T1 马上执行；等 T1 执行完，再唤醒 T2，也能保证同一时刻只有一个线程执行。但是相比 Hasen 模型，T2 **多了一次阻塞唤醒操作**。
- MESA 管程里面，T2 通知完 T1 后，T2 还是会接着执行，T1 并不立即执行，仅仅是从条件变量的等待队列进到入口等待队列里面。这样做的好处是 `notify()` 不用放到代码的最后，T2 也没有多余的阻塞唤醒操作。但是也有个副作用，**就是当 T1 再次执行的时候，可能曾经满足的条件，现在已经不满足了，所以需要以循环方式检验条件变量**。

### `notify()` 何时可以使用

前面说到，**除非经过深思熟虑，否则尽量使用 `notifyAll()`**。那什么时候可以使用 `notify()` 呢？需要满足以下三个条件：

1. 所有等待线程拥有相同的等待条件；
2. 所有等待线程被唤醒后，执行相同的操作；
3. 只需要唤醒一个线程。

### Java 内置的管程（synchronized）只支持一个条件变量

Java 参考了 MESA 模型，语言内置的管程（synchronized）对 MESA 模型进行了精简。MESA 模型中，条件变量可以有多个，但 Java 语言内置的管程里只有一个条件变量。从下面代码可以看出

```java
synchronized(obj){
    //只能调用 obj.wait() 等方法
    while(!condition){
        obj.wait();
    }
}
```

- Java 内置的管程方案（synchronized）使用简单，synchronized 关键字修饰的代码块，在编译期会自动生成相关加锁和解锁的代码，但是仅支持一个条件变量。
- Java SDK JUC 并发包实现的管程支持多个条件变量，不过并发包里的锁，需要开发人员自己进行加锁和解锁操作。

---
## 3 总结

并发编程里两大核心问题——互斥和同步，都可以由管程来帮你解决。学好管程，理论上所有的并发问题你都可以解决，并且很多并发工具类底层都是管程实现的，所以学好管程，就是相当于掌握了一把并发编程的万能钥匙。

---
## 4 思考

`wait()` 方法，在 Hasen 模型和 Hoare 模型里面，都是没有参数的，而在 MESA 模型里面，增加了超时参数，你觉得这个参数有必要吗？

- 在 Hasen 模型和 Hoare 模型里面，当通知线程通知完后不是阻塞就是结束了，能保证被通知线程一定会被执行。
- 而在 MESA 模型里面，被通知的线程会重新回到入口队列，再去竞争锁，如果线程的优先级比较低，可能一直得不到执行权，这样就会造成饥饿。
