# Java 线程

## 1 Java 线程生命周期

- 线程是操作系统里的一个概念，虽然各种不同的开发语言如 `Java、C#` 等都对其进行了封装，但是万变不离操作系统。Java 语言里的线程本质上就是操作系统的线程，它们是一一对应的。
- 对于有生命周期的事物，要学好它，思路非常简单，只要能**搞懂生命周期中各个节点的状态转换机制**就可以了。

### 1.1 通用线程生命周期——五态模型

五态模型包括：初始状态、可运行状态、运行状态、休眠状态和终止状态。这是操作系统底层层面的，其他编程语言的线程都是基于此进行封装的。

![08_common_thread_lifecycle](images/08_common_thread_lifecycle.png)

1. **初始状态**
   1. 属于编程语言所特有，在编程语言层面，线程已经被创建，但是还不允许分配 CPU 执行。
   2. 仅仅是在编程语言层面被创建，在操作系统层面，真正的线程还没有创建。
2. **可运行状态**：操作系统线程已经被成功创建了，所以可以分配 CPU 执行。
3. **运行状态**：被分配到 CPU 的线程。
4. **休眠状态**
   1. 运行状态的线程如果调用一个阻塞的 API（例如以阻塞方式读文件）或者等待某个事件（例如条件变量）会进入阻塞状态。
   2. 休眠的线程会释放 CPU 使用权。
   3. 休眠状态的线程永远没有机会获得 CPU 使用权。
5. **终止状态**：线程执行完或者出现异常就会进入终止状态，声明周期结束。

不同的编程语言对上述状态进行了合并或者细分，比如：

- C 语言的 POSIX Threads 规范，合并了初始状态和可运行状态。
- Java 语言里合并了可运行状态和运行状态，这两个状态在操作系统调度层面有用，而 JVM 层面不关心这两个状态，因为 JVM 把线程调度交给操作系统处理了。
- Java 语言里细化了休眠状态，分出来阻塞、等待、超时等待。

### 1.2 Java 线程的生命周期

Java 语言中线程共有六种状态，分别是：

1. NEW（初始化状态）
2. RUNNABLE（可运行 / 运行状态）
3. BLOCKED（阻塞状态）
4. WAITING（无时限等待）
5. TIMED_WAITING（有时限等待）
6. TERMINATED（终止状态）

Java 线程中的 BLOCKED、WAITING、TIMED_WAITING 在操作系统层面是同一种状态，即休眠状态，只要 Java 线程处于这三种状态之一，那么这个线程就永远没有 CPU 的使用权。

简化后的Java 线程生命周期图：

![08_java_thread_lifecycle.png](images/08_java_thread_lifecycle.png)

### 1.3 Java 线程生命周期的转换

#### RUNNABLE 与 BLOCKED 的状态转换

只有一种场景会触发这种转换：

- 线程等待 synchronized 的隐式锁，会进入 BLOCKED 状态。
- 线程获取到 synchronized 的隐式锁，或进入 RUNNABLE 状态。

**JVM 层面并不关心操作系统调度相关的状态**：

- 在操作系统层面，线程调用阻塞式 API 时，会转换到休眠状态，但是在 JVM 层面，Java 线程的状态不会发生变化。
- 线程调用阻塞式 API 时，Java 线程的状态会依然保持 RUNNABLE 状态。
- 在 JVM 看来，等待 CPU 使用权（操作系统层面此时处于可执行状态）与等待 I/O（操作系统层面此时处于休眠状态）没有区别，都是在等待某个资源，所以都归入了 RUNNABLE 状态。
- 我们平时所谓的 Java 在调用阻塞式 API 时，线程会阻塞，指的是操作系统线程的状态，并不是 Java 线程的状态。

#### RUNNABLE 与 WAITING 的状态转换

- 第一种场景，获得 synchronized 隐式锁的线程，调用无参数的 `Object.wait()` 方法。
- 第二种场景，调用无参数的 `Thread.join()` 方法。
- 第三种场景，调用 `LockSupport.park()` 方法。

#### RUNNABLE 与 TIMED_WAITING 的状态转换

有五种场景会触发这种转换：

1. 调用带超时参数的 `Thread.sleep(long millis)` 方法；
2. 获得 synchronized 隐式锁的线程，调用带超时参数的 `Object.wait(long timeout)` 方法；
3. 调用带超时参数的 `Thread.join(long millis)` 方法；
4. 调用带超时参数的 `LockSupport.parkNanos(Object blocker, long deadline)` 方法；
5. 调用带超时参数的 `LockSupport.parkUntil(long deadline)` 方法。

#### 从 NEW 到 RUNNABLE 状态

Java 刚创建出来的 Thread 对象就是 NEW 状态。

#### 从 RUNNABLE 到 TERMINATED 状态

- 线程执行完 `run()` 方法后，会自动转换到 TERMINATED 状态。
- 如果执行 `run()` 方法的时候异常抛出，也会导致线程终止。

### 1.4 停止 Java 线程：`stop()` 和 `interrupt()` 方法的主要区别是什么

stop 方法已经被废弃，新的 Java 中，其甚至被移除了，原因如下：

1. `stop()` 方法会真的杀死线程，不给线程喘息的机会。
2. 线程占用的资源可能无法被释放，如果线程持有 ReentrantLock 锁，被 `stop()` 的线程并不会自动调用 ReentrantLock 的 `unlock()` 去释放锁，那其他线程就再也没机会获得 ReentrantLock 锁。
3. 如果线程正在执行某个重要的逻辑，还没有被执行完就被杀死了，可到导致程序结果无法预测。

要停止线程，推荐的方法是  `interrupt()`，`interrupt()` 方法仅仅是通知线程，被 interrupt 的线程可以选择处理整个通知也可以选择忽略，所以线程的终止是协作式的。被 interrupt 的线程，是怎么收到通知的呢？一种是异常，另一种是主动检测。

1. 当线程处于 WAITING、TIMED_WAITING 状态时，如果其他线程调用线程的 `interrupt()` 方法，会使线程 A 返回到 RUNNABLE 状态，同时线程 A 的代码会触发 InterruptedException 异常。回想一下，调用 `wait()、join()、sleep()` 等方法进入 WAITING、TIMED_WAITING 状态，而这些方法都会 throws InterruptedException 异常，这个异常的触发条件就是：其他线程调用了该线程的 `interrupt()` 方法。
2. 当线程 A 处于 RUNNABLE 状态时，并且阻塞在 `java.nio.channels.InterruptibleChannel` 上时，如果其他线程调用线程 A 的 `interrupt()` 方法，线程 A 会触发 `java.nio.channels.ClosedByInterruptException` 这个异常。
3. 如果线程处于 RUNNABLE 状态，并且没有阻塞在某个 I/O 操作上，例如中断计算圆周率的线程 A，这时就得依赖线程 A 主动检测中断状态了。如果其他线程调用线程 A 的 `interrupt()` 方法，那么线程 A 可以通过 `isInterrupted()` 方法，检测是不是自己被中断了。

当前线程被中断之后，退出 `while(true)` 的正确姿势：

```java
Thread th = Thread.currentThread();

while(true) {
  if(th.isInterrupted()) {
    break;
  }
  // 省略业务代码无数
  try {
    Thread.sleep(100);
  }catch (InterruptedException e){
    //线程在sleep期间被打断了，抛出一个InterruptedException异常，try catch捕捉此异常，应该重置一下中断标示，因为抛出异常后，中断标示会自动清除掉
    Thread.currentThread().interrupt();
    e.printStackTrace();
  }
}
```

### 1.5 总结

- 理解 Java 线程的各种状态以及生命周期对于诊断多线程 Bug 非常有帮助。
- 多线程程序很难调试，出了 Bug 基本上都是靠日志，靠线程 dump 来跟踪问题，分析线程 dump 的一个基本功就是分析线程状态，大部分的死锁、饥饿、活锁问题都需要跟踪分析线程的状态。
- 出现并发问题时可以通过 `jstack` 命令或者 Java VisualVM 这个可视化工具将 JVM 所有的线程栈信息导出来进行。

## 2 如何设置合适的线程数量

使用多少个线程却是个困难的问题，比如我们经常遇到的问题

- 各种线程池的线程数量调整成多少是合适的？
- Tomcat 的线程数、Jdbc 连接池的连接数是多少？

要解决这个问题，首先要分析以下两个问题：

为什么要使用多线程？
多线程的应用场景有哪些？

### 2.1 为什么使用多线程：提升性能

抛开编程模型，使用多线程，本质上就是提升程序性能。那么如何度量性能？

核心指标：延迟和吞吐量：

- 延迟指的是发出请求到收到响应这个过程的时间；延迟越短，意味着程序执行得越快，性能也就越好。
- 吞吐量指的是在单位时间内能处理请求的数量；吞吐量越大，意味着程序能处理的请求越多，性能也就越好。

两者之间的关系：

- 延迟和吞吐量内部有一定的联系（同等条件下，延迟越短，吞吐量越大）。
- 同时延迟和吞吐量又隶属不同的维度（一个是时间维度，一个是空间维度），并不能互相转换。

提升性能，从度量的角度，主要是**降低延迟，提高吞吐量**。

### 2.2 降低延迟，提高吞吐量

想要降低延迟，提高吞吐量，有两个方向：

- 一个方向是优化算法，这属于另一个范畴了。
- 一个方向是将硬件的性能发挥到极致。

将哪些硬件的性能发挥到极致？

1. 一个是 I/O
2. 一个是 CPU

所以**在并发编程领域，提升性能本质上就是提升硬件的利用率，再具体点来说，就是提升 I/O 的利用率和 CPU 的利用率**。

操作系统在一定层面上已经解决了硬件的利用率问题，例如操作系统已经解决了磁盘和网卡的利用率问题，利用中断机制还能避免 CPU 轮询 I/O 状态，也提升了 CPU 的利用率。但是操作系统解决硬件利用率问题的对象往往是单一的硬件设备，而我们的并发程序，往往**需要 CPU 和 I/O 设备相互配合工作**，也就是说，我们**需要解决 CPU 和 I/O 设备综合利用率的问题**。对于 CPU 和 I/O 设备综合利用率的问题，没有放之四海而皆准的标准，所以操作系统只能提供优化方案——多线程，让开发者自己去针对特定场景进行优化。

### 2.3 如何利用多线程来提升 CPU 和 I/O 设备的利用率

需要针对特定场景进行分析，假设程序按照 CPU 计算和 I/O 操作交叉执行的方式运行，而且 CPU 计算和 I/O 操作的耗时是 `1:1`

当只有一个线程时：

- 执行 CPU 计算的时候，I/O 设备空闲；
- 执行 I/O 操作的时候，CPU 空闲；
- CPU 的利用率和 I/O 设备的利用率都是 50%。

![08_improve_performance_1.png](images/08_improve_performance_1.png)

当有两个线程时：

- 当线程 A 执行 CPU 计算的时候，线程 B 执行 I/O 操作；
- 当线程 A 执行 I/O 操作的时候，线程 B 执行 CPU 计算；
- CPU 的利用率和 I/O 设备的利用率就都是 100%。

![08_improve_performance_1.png](images/08_improve_performance_2.png)

从一个线程到两个线程，CPU 的利用率和 I/O 设备的利用率都提升到了 100%，单位时间处理的请求数量翻了一番，也就是说吞吐量提高了 1 倍，因此可推断出：**如果 CPU 和 I/O 设备的利用率都很低，那么可以尝试通过增加线程来提高吞吐量**。

### 2.4 单核 CPU 与多核 CPU

- 在单核时代，多线程主要就是用来平衡 CPU 和 I/O 设备的。如果程序只有 CPU 计算，而没有 I/O 操作的话，多线程不但不会提升性能，还会使性能变得更差，原因是增加了线程切换的成本。
- 在多核时代，这种纯计算型的程序也可以利用多线程来提升性能，因为利用多核可以降低响应时间。

### 2.5 创建多少线程合适

创建多少线程要看多线程具体的应用场景，应用场景主要看任务类型，一般都是 CPU 计算和 I/O 操作交叉执行的，根据它们的任务比重，可以分为：

- **I/O 密集型计算**：由于 I/O 设备的速度相对于 CPU 来说都很慢，大部分情况下，I/O 操作执行的时间相对于 CPU 计算来说都非常长。
- **CPU 密集型计算**：大部分场景下都是纯 CPU 计算。

I/O 密集型程序和 CPU 密集型程序，计算最佳线程数的方法是不同的。

#### CPU 密集型计算

1. 对于 CPU 密集型计算，多线程本质上是提升多核 CPU 的利用率，理论上每一个核对应一个线程即可，多余的线程只会增加线程切换的成本。
2. 在工程上，线程的数量一般会设置为`“CPU 核数 +1”`，这样的话，当线程因为偶尔的内存页失效或其他原因导致阻塞时，这个额外的线程可以顶上，从而保证 CPU 的利用率。

#### `I/O` 密集型的计算场景

对于 I/O 密集型计算场景，最佳的线程数是与程序中 CPU 计算和 I/O 操作的耗时比相关的，我们可以总结出这样一个公式：

```log
最佳线程数 =1 +（I/O 耗时 / CPU 耗时）
```

令 `R=I/O 耗时 / CPU 耗时`，可以这样理解：当线程 A 执行 IO 操作时，另外 R 个线程正好执行完各自的 CPU 计算。这样 CPU 的利用率就达到了 100%。

上面这个公式是针对单核 CPU 的，至于多核 CPU，也很简单，只需要等比扩大就可以了，计算公式如下：

```log
最佳线程数 =CPU 核数 * [ 1 +（I/O 耗时 / CPU 耗时）]
```

### 2.6 总结

- 设置多少个线程合适，其实只要把握**将硬件的性能发挥到极致**这个原则即可。
- 对于 I/O 密集型计算场景，I/O 耗时和 CPU 耗时的比值是一个关键参数，不幸的是这个参数是未知的，而且是动态变化的，所以工程上，我们要估算这个参数，然后做各种不同场景下的压测来验证我们的估计。
- 工程上，原则还是将硬件的性能发挥到极致，所以压测时，我们需要重点关注 CPU、I/O 设备的利用率和性能指标（响应时间、吞吐量）之间的关系。

### 2.7 思考

有些同学对于最佳线程数的设置积累了一些经验值，认为对于 I/O 密集型应用，最佳线程数应该为：`2 * CPU 的核数 + 1`，你觉得这个经验值合理吗？

不合理，但是却可以使用，因为：

1. 不合理的原因，按照上述讲解，需要针对 `I/O 耗时 / CPU 耗时`比来确定线程数，还需要进行测试和分析来验证线程数是否合理，而不是评经验去设置。
2. 可以使用是因为：从理论上来讲，这个经验值一定是靠不住的。但是经验值对于很多`“I/O 耗时 / CPU 耗时”`不太容易确定的系统来说，却是一个很好到初始值。

那么如何在实际工作中去优化初始值呢？

1. 实际工作中大家面临的系统，“I/O 耗时 / CPU 耗时”往往都大于 1，所以基本上都是在这个初始值的基础上增加。
2. 增加的过程中，应关注线程数是如何影响吞吐量和延迟的。
   1. 一般随着线程数的增加，吞吐量会增加，延迟也会缓慢增加；
   2. 当线程数增加到一定程度，吞吐量就会开始下降，延迟会迅速增加，这个时候基本上就是线程能够设置的最大值了。

### 2.8 扩展

- 实际项目中怎么确定IO耗时、CPU耗时？apm 工具可以精确到方法耗时。
- 因特尔有拥有超程技术，此时如何确定核数？按照逻辑核数设置，最终还是要根据压测数据调整的。
- 推荐阅读：[About Pool Sizing](https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing)

## 3 为什么局布变量是线程安全的

### 3.1 局布变量的存储位置

- 每个方法在调用栈里都有自己的独立空间，称为栈帧，每个栈帧里都有对应方法需要的参数和返回地址。当调用方法时，会创建新的栈帧，并压入调用栈；当方法返回时，对应的栈帧就会被自动弹出。也就是说，栈帧和方法是同生共死的。
- 局部变量存放在调用栈中。
- 每个线程都有自己独立的调用栈，无论多少个线程调用方法，它们都有各自私有的栈帧。

### 3.2 线程封闭

方法里的局部变量，因为不会和其他线程共享，所以没有并发问题，这个思路已经成为解决并发问题的一个重要技术——线程封闭，即**仅在单线程内访问数据**。由于不存在共享，所以即便不同步也不会有并发问题，性能杠杠的。
