# 安全性、活跃性以及性能问题

并发编程中我们需要注意的问题有很多，主要有三个方面，分别是：

- 安全性问题
- 活跃性问题
- 性能问题

## 1 安全性问题

**什么是安全性问题**？

- 在并发编程领域，我们衡量一个类时，通常会问：“这个方法不是线程安全的，这个类不是线程安全的？”
- 什么是线程安全？其实本质上就是正确性，而正确性的含义就是**程序按照我们期望的执行**，不要让我们感到意外。
- 并发 Bug 的三个主要源头：原子性问题、可见性问题和有序性问题。理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。

安全性问题即在并发条件下，程序能否按照我们的期望去执行。

**什么情况下需要考虑线程安全**？

- 不是所有的代码都需要认真分析一遍是否存在原子性问题、可见性问题和有序性问题。
- 只有存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据才需要考虑线程。

不存在共享数据，即可以保证线程安全，此类技术有很多实现：

- 线程本地存储（Thread Local Storage，TLS）
- 不变模式

但是，现实情况下，必须共享会发生变化的数据的应用场景还是很多的。

### 1.1 安全性问题——数据竞争

**数据竞争（Data Race）**：

1. 定义：当`多个`线程`同时地`访问`同一共享数据`，并且`至少有一个线程会写`这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug。
2. 后果：如果发生了数据争用，读取共享变量时得到的值将变得不可知，使得该多线程程序的运行结果将完全不可预测，可能直接崩溃。

参考下面代码，当多个线程调用时候就会发生数据竞争，count 的结果是无法预知的:

```java
public class Test {

  private long count = 0;

  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      count += 1;
    }
  }

}
```

### 1.2 安全性问题——竞态条件

竞态条件又名竞争冒险（race hazard）、竞争条件（race condition）。

1. 定义：受各线程上代码执行的顺序和时机的影响，程序的运行结果产生（预料之外）的变化。
2. 后果：如果存在竞态条件(race condition)，多次运行程序对于同一个输入将会有不同的结果，但结果并非完全不可预测，它将由输入数据和各线程的执行顺序共同决定。
3. 不是简单地加锁就能避免所有并发问题，我们还需要明确加锁的临界区。

- 示例 1：

```java
public class Test {

  private long count = 0;

  synchronized long get(){
    return count；
  }

  synchronized void set(long v){
    count = v;
  }

  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      //get() + 1 存在竞态条件。
      set(get()+1)
    }
  }
}
```

这个程序也不是安全的，`set(get() + 1)` 存在安全隐患，虽然我们给所有访问 count 的地方都加了锁，避免了数据竞争，但是程序的正确性依赖于线程的执行顺序，原因在于 `set(get()+1)` 操作不是原子的，线程执行 set 时，可能它读取到的数据已经发生修改了。

- 实例 2：

```java
//获取库存数量
lock.lock();
int count = getInventory(merchandiseId)
lock.unlock();

//库存大于等于购买
lock.lock();
boolean isBuy = count >= purchaseQuantity;
lock.unlock();

if(isBuy) {
  //生成订单
  lock.lock();
  //库存-1
  lock.unlock();
  //出库......
}else {
  throw new MerchandHungerException("库存不足");
}
```

以上代码在多线程执行时并不会出现数据竞争，因为不会有多个线程同时对数据进操作，所以对数据的操作都只会有一个线程，但其还是存在竟态条件的，因为这些共享数据还是会在某个线程没有持有锁的情况下会被其它线程修改，导致当前获得的状态是失效的。该例子参考自[什么是竞态条件？什么是数据竞争？](http://www.spring4all.com/article/806)。

- 实例3：转账中的竞态条件

```java
class Account {

  private int balance;

  // 转账
  void transfer(Account target, int amt){
    if (this.balance > amt) {
      this.balance -= amt;
      target.balance += amt;
    }
  }

}
```

银行转账是不允许超额转出的，假设  A 账户余额 150 元，两个线程都执行从 A 账户转出金额 150 元，如果两个线程都执行到 `if (this.balance > amt)` 这一行，那么这里的判断条件就没有起到作用，两个线程都从 A 账户转出 150 元，就导致账户余额异常了。其实该例子即存在竞态条件也存在数据竞争。

**如何理解理解竞态条件**？

在并发场景中，程序的执行依赖于某个状态变量，类似于下面伪代码：

```java
if (状态变量 满足 执行条件) {
    执行操作
}
```

1. 当某个线程发现状态变量满足执行条件后，开始执行操作。
2. 就在这个线程执行操作的时候，其他线程却修改了状态变量，导致状态变量不满足执行条件了。

总结：线程执行操作的判断操作，与线程将要执行的操作，不是原子性的，而将要执行的操作又会导致判断条件的结果发生变化，这个将会导致判断条件的结果发生变化操作，可能被其他线程抢先执行。

关于竞态条件和数据竞争可以参考下面链接：

- [《维基百科》](https://zh.wikipedia.org/wiki/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3)
- [什么是竞态条件？什么是数据竞争？](http://www.spring4all.com/article/806)
- [别混淆数据争用(data race) 和竞态条件(race condition)](https://blog.csdn.net/gg_18826075157/article/details/72582939)

### 解决数据竞争和竞态条件问题——锁

面对数据竞争和竞态条件问题，该如何保证线程的安全性？其实这两类问题，都可以用互斥这个技术方案，即加锁技术。

## 2 活跃性问题

活跃性问题，指的是**某个操作无法执行下去**。处理常见的死锁，还有活锁和饥饿。发生“死锁”后线程会互相等待，而且会一直等待下去，在技术上的表现形式是线程永久地“阻塞”了。

### 活锁

**有时线程虽然没有发生阻塞，但仍然会存在执行不下去的情况，这就是所谓的“活锁”**。

死锁活锁本质上是一样的，原因都是临界区获取资源时，并发的多个线程需要获取多个资源，但它们声明资源暂用顺序不一致：加锁有两个资源 A 和 B，线程 1 进入临界区成功获取到 A，线程 2 进入临界去成功获取到 B，但是当线程 1 尝试获取 B 资源时发现该资源已经被其他线程获取了。同样线程 2 去获取 A 资源时也发现该资源已经被其他线程获取。

- 死锁的情况是，线程 1 和 线程 2，因为都拿不到资源一致等下去，但是永远也等不到。
- 活锁的情况时，线程 1 释放自己占用的资源 A 去获取 B，线程 2 释放自己占用的资源 B 去获取 A。

活锁：

```log
P1 lock A
P2 lock B

start：
P1 lock B fail    context switch
P2 lock A fail    context switch

P1 release A
P2 release B

goto start
```

具体可以参考[并发问题中活锁（live lock）到底指的是什么？](https://www.zhihu.com/question/20566246)

**如何解决活锁问题**？解决“活锁”的方案很简单，**线程释放资源时，尝试等待一个随机的时间就可以了**。Raft 这样知名的分布式一致性算法中也用到了这种思想。

### 饥饿

**所谓“饥饿”指的是线程因无法访问所需资源而无法执行下去的情况**。如果线程优先级“不均”，在 CPU 繁忙的情况下，优先级低的线程得到执行的机会很小，就可能发生线程“饥饿”；持有锁的线程，如果执行的时间过长，也可能导致“饥饿”问题。

**如何解决饥饿问题**？

解决“饥饿”问题的方案很简单，有三种方案：

1. 保证资源充足。
2. 公平地分配资源。
3. 避免持有锁的线程长时间执行。

这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。方案二的适用场景相对来说更多一些。如何公平地分配资源：在并发编程里，主要是使用公平锁。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。

## 3 性能问题

### 锁的过度使用会造成性能问题

- 使用“锁”要非常小心，但是如果小心过度，也可能出“性能问题”。
- “锁”的过度使用可能导致串行化的范围过大，这样就不能够发挥多线程的优势了，而我们之所以使用多线程搞并发程序，为的就是提升性能。

### 阿姆达尔（Amdahl）定律

串行对性能的影响是怎么样的呢？假设串行百分比是 5%，我们用多核多线程相比单核单线程能提速多少呢？我们可以使用 **阿姆达尔（Amdahl）定律** 来计算，，阿姆达尔定律代表了处理器并行运算之后效率提升的能力，具体公式如下：

```math
S = 1/((1-p) + (p/n))
```

- n 可以理解为 CPU 的核数
- p 可以理解为并行百分比，`(1-p)`即串行百分比。

假设 CPU 的核数（也就是 n）无穷大，那加速比 S 的极限就是 20，也就是说，如果我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。

>那么串行百分比一般怎么得出来呢？临界区都是串行的，非临界区都是并行的，公式：`用单线程执行临界区的时间 / 用单线程执行(临界区+非临界区)的时间 = 串行百分比`。

### 使用锁一定要关注性能问题

使用锁的时候一定要关注对性能的影响。 那怎么才能避免锁带来的性能问题呢？这个问题很复杂，Java SDK 并发包里之所以有那么多东西，有很大一部分原因就是要提升在某个特定领域的性能。

从方案层面，我们可以这样来解决这个问题：

1. 既然使用锁会带来性能问题，那最好的方案自然就是使用无锁的算法和数据结构。相关技术有：
   1. 线程本地存储 (Thread Local Storage, TLS)
   2. 写入时复制 (Copy-on-write)
   3. 乐观锁
   4. 使用无锁的数据结构，比如 JUC 中的 Atomic 系类类。
2. 减少锁持有的时间。互斥锁本质上是将并行的程序串行化，所以要增加并行度，一定要减少持有锁的时间。相关技术有：
   1. 使用细粒度的锁，比如 JDK1.8 之前的  ConcurrentHashMap
   2. 读写锁

### 性能方面的度量指标：吞吐量、延迟和并发量

1. 吞吐量：指的是单位时间内能处理的请求数量。吞吐量越高，说明性能越好。
2. 延迟：指的是从发出请求到收到响应的时间。延迟越小，说明性能越好。
3. 并发量：指的是能同时处理的请求数量，一般来说随着并发量的增加、延迟也会增加。所以延迟这个指标，一般都会是基于并发量来说的。例如并发量是 1000 的时候，延迟是 50 毫秒。

## 4 总结

1. 并发编程是一个复杂的技术领域，微观上涉及到原子性问题、可见性问题和有序性问题，宏观则表现为安全性、活跃性以及性能问题。
2. 在设计并发程序的时候，主要是从宏观出发，也就是要重点关注它的安全性、活跃性以及性能。
3. 安全性方面要注意数据竞争和竞态条件。
4. 活跃性方面需要注意死锁、活锁、饥饿等问题。
5. 性能方面遇到具体问题需要具体分析，根据特定的场景选择合适的数据结构和算法。

**总之：要解决问题，必须先把问题搞清楚**。

## 5 思考

Java 语言提供的 Vector 是一个线程安全的容器，有同学写了下面的代码，你看看是否存在并发问题呢？

```java
void addIfNotExist(Vector v, Object o){

  if(!v.contains(o)) {
    v.add(o);
  }

}
```

Vector 是线程安全的，但是只提供方法级的线程安全，即 `contains()` 和 `add()` 方法虽然都是线程安全的，但是组合在一起却不是线程安全的，在这里就存在竞态条件，正确的方式应该是应用面向对象思想，对 Vector 再封装一次：

```java
class SafeVector{

  private Vector v;

  // 所有公共方法增加同步控制
  synchronized  void addIfNotExist(Object o){
    if(!v.contains(o)) {
      v.add(o);
    }
  }
}
```
