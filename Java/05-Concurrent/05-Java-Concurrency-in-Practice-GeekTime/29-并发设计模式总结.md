# 并发设计模式总结

多线程设计模式是前人解决并发问题的经验总结，当我们试图解决一个并发问题时，首选方案往往是使用匹配的设计模式，这样能避免走弯路。同时，由于大家都熟悉设计模式，所以使用设计模式还能提升方案和代码的可理解性。

## 1 避免共享的设计模式

1. Immutability 模式：需要注意对象属性的不可变性。
2. Copy-on-Write 模式：需要注意性能问题。
3. 线程本地存储模式：需要注意异步执行问题。

## 2 多线程版本 IF 的设计模式

Guarded Suspension 模式和 Balking 模式都可以简单地理解为“**多线程版本的 if**”，但它们的区别在于前者会等待 if 条件变为真，而后者则不需要等待。

1. **Guarded Suspension 模式**：经典实现是使用管程，很多初学者会简单地用线程 sleep 的方式实现，但不推荐你使用这种方式，最重要的原因是性能，如果 sleep 的时间太长，会影响响应时间；sleep 的时间太短，会导致线程频繁地被唤醒，消耗系统资源。
2. **Balking 模式**：实现时最容易忽视的就是竞态条件问题，因此，在多线程场景中使用 if 语句时，一定要多问自己一遍：是否存在竞态条件。

## 3 三种最简单的分工模式

1. **Thread-Per-Message 模式**：Thread-Per-Message 模式在实现的时候需要注意是否存在线程的频繁创建、销毁以及是否可能导致 OOM。在高并发场景中，解决 OOM 最简单的办法其实是限流。
2. **Worker Thread 模式**：Worker Thread 模式的实现，需要注意潜在的线程死锁问题。共享线程池虽然能够提供线程池的使用效率，但一定要保证一个前提，那就是：任务之间没有依赖关系。
3. **生产者-消费者模式**：Java 线程池本身就是一种生产者 - 消费者模式的实现，所以大部分场景你都不需要自己实现，直接使用 Java 的线程池就可以了。但若能自己灵活地实现生产者-消费者模式会更好，比如可以实现批量执行和分阶段提交，不过这过程中还需要注意如何优雅地终止线程。

## 4 如何优雅地终止线程：两段式与毒丸对象

两阶段终止模式是一种通用的解决方案。但其实终止生产者-消费者服务还有一种更简单的方案，叫做“毒丸”对象。《Java 并发编程实战》第 7 章的 7.2.3 节对“毒丸”对象有过详细的介绍。简单来讲，“毒丸”对象是生产者生产的一条特殊任务，然后当消费者线程读到“毒丸”对象时，会立即终止自身的执行。

## 5 扩展

更多并发设计模式可以参考 《图解 Java 多线程设计模式》。
