# 互斥锁

## 1 解决原子性问题

### 如何解决原子性问题

- 禁止线程切换：仅在单核 CPU 上有效。
- 使用互斥锁。

### 使用互斥锁解决原子性问题

- 什么是互斥：“同一时刻只有一个线程执行”，我们称之为互斥。只要保证对共享资源的操作是互斥的，无论是单核 CPU 还是多核 CPU，就都能保证原子性。
- 什么是临界区：我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁 `lock()`，如果成功，则进入临界区，此时我们称这个线程持有锁；否则就等待，直到持有锁的线程解锁。

### 正确的锁模型

我们要明确锁和锁要保护的资源是有对应关系的，在并发编程中，我们要时刻注意这一点。否则可能出现锁自家门来保护他家资产的事情。

### Java 语言提供的锁技术：synchronized

- synchronized 是 Java 在语言层面提供的互斥原语。
- synchronized 对加锁的方法或代码块自动加锁和解锁。

注意下面代码 `用 synchronized 解决 count+=1 问题`：

```java
class SafeCalc {

  private long value = 0L;

  long get() {
    return value;
  }

  synchronized void addOne() {
    value += 1;
  }

}
```

上面 `addOne()` 操作是否对 `get()` 可见？答案是不可见的，因为 get 方法并没有被加锁，addOne 和 get 之间没有任何 happen-before 规则。

### 锁和受保护资源的关系

受保护资源和锁之间的关联关系非常重要，一个合理的关系是：**受保护资源和锁之间的关联关系是 N:1 的关系**。

对应的有以下注意点：

- 不要拿多个锁来保护一个资源。这样加锁无法保证并发安全。
- 同一把锁来保护多个资源。这叫粗粒度锁。

### 思考

下面的代码用 synchronized 修饰代码块来尝试解决并发问题，是否正确？

```java
class SafeCalc {

  long value = 0L;

  long get() {
    synchronized (new Object()) {
      return value;
    }
  }

  void addOne() {
    synchronized (new Object()) {
      value += 1;
    }
  }
}
```

这样做是没有任何作用的：

1. 每次调用方法 `get()、addOne()` 都创建了不同的锁，相当于无锁。“**一个合理的受保护资源与锁之间的关联关系应该是 N:1**”。只有共享一把锁才能起到互斥的作用。
2. JVM 开启逃逸分析之后，`synchronized (new Object())` 这行代码在实际执行的时候会被优化掉，也就是说在真实执行的时候，这行代码压根就不存在。

## 2 如何用一把锁保护多个资源？

### 保护没有关联关系的多个资源

对于没有关联关系的多个资源，应该采用多个锁分别进行保护，因为使用同一个锁保护多个资源会降低性能（对这个多个变量的操作都是串行的），**用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁**。

### 保护有关联关系的多个资源

**转账问题**：转账涉及到对两个用户的账户操作，一个加，一个减，这两个操作要么一起成功，要是一起失败，假设每个用户对应一个 Account 类，如何加锁呢？

思路如下：

- 明确要保护的资源：账户 A 和账户 B。
- 我们加的锁必须能覆盖所有受保护资源。

最简单的方式就是使用一个粗粒度锁，该锁保护所有账户，比如全局只有一份的`Account.class`对象。

```java
class Account {
  private int balance;

  // 转账
  void transfer(Account target, int amt){
    synchronized(Account.class) {
      if (this.balance > amt) {
        this.balance -= amt;
        target.balance += amt;
      }
    }
  }
}
```

对于有关联关系的多个资源，锁必须能覆盖所有受保护资源，此时应该使用粗粒度锁。

### 原子性的本质

“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，**操作的中间状态对外不可见**。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以**解决原子性问题，是要保证中间状态对外不可见**。

### 思考

下面加锁方式是否正确？

```java
class Account {

  // 账户余额  
  private Integer balance;
  // 账户密码
  private String password;
  // 取款
  void withdraw(Integer amt) {
    synchronized(balance) {
      if (this.balance > amt){
        this.balance -= amt;
      }
    }
  }

  // 更改密码
  void updatePassword(String pw){
    synchronized(password) {
      this.password = pw;
    }
  }
}
```

这样加锁，存在严重的漏洞

1. 余额和秘密都是可变的，锁如果锁发生变化，就意味着失去了互斥功能。
2. Integer 和 String 类型的对象在 JVM 里面是可能被重用的，除此之外还有 Boolean，重用意味着你的锁可能被其他代码使用，如果其他代码 synchronized(你的锁)，而且不释放，那你的程序就永远拿不到锁，这是隐藏的风险。
3. 所以我们可以总结出：**锁，应是私有的、不可变的、不可重用的**。
