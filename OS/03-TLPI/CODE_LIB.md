# tlpi 学习

## 1 lib 说明

>lib 中的头文件是 tlpi 一书提供的通用函数封装，提供了包括错误处理、解析数值型命令行参数等功能。

本节整理自原书第三章第五节：关于本书示例程序的注意事项。

### 命令行选项及参数

传统的 UNIX 命令行选项由一个连字符（-）、表示选项的英文字母，以及一个可选参数组成，可使用标准库函数 `getopt()`（参见附录 B）对命令行选项进行解析。

### 常用的函数及头文件

#### 错误诊断函数

为简化本书程序示例中的错误处理，我们编写了错误诊断函数，路径为 `lib/error_functions.h`，本书使用 `errMsg()、errExit()、err_exit()以及 errExitEN()`函数，以诊断调用系统调用和库 函数时所发生的错误。

- 函数 `errMsg()` 会在标准错误设备上打印消息。除了将一个终止换行符自动追加到输出字符串尾部以外，该函数的参数列表与 `printf()` 所用相同。`errMsg()` 函数会打印出与当前 errno 值相对应的错误文本，其中包括了错误名（比如，EPERM）以及由 `strerror()`返回的错误描述，外加由参数列表指定的格式化输出。
- `errExit()` 函数的操作方式与 `errMsg()` 相似，只是还会以如下两种方式之一来终止程序。
  - 其一，调 用 `exit()` 退出。
  - 其二，若将环境变量 `EF_DUMPCORE` 定义为非空字符串，则调用 abort() 退出，同时生成核心转储（core dump）文件，供调试器调试之用。
- 函数 `err_exit()` 类似于 `errExit()`，但存在两方面的差异。
  - 打印错误消息之前，`err_exit()` 不会刷新标准输出。
  - `err_exit()` 终止进程使用的是 `_exit()`，而非 `exit()`。这一退出方式，略去了对 stdio 缓冲区的刷新以及对退出处理程序（exit handler）的调用。
- 在功能上，`errExitEN()` 函数与 `errExit()` 大体相同，区别仅仅在于：与 `errExit()` 打印与当前 errno 值相对应的错误文本不同，`errExitEN()` 只会打印与 errnum 参数中给定的错误号（error number）相对应的文本。

在编写的库函数创建了子进程，且该子进程因发生错误而需要 终止时，`err_exit()` 恰好能一显身手。它避免了对子进程继承自父进程（即调用进程）的 stdio 缓冲区副本进行刷新，且不会调用由父进程所建立的退出处理程序。

在本书中调用了 POSIX 线程 API 的程序示例中，主要使用 `errExitEN()` 来处理错误。与传统的 UNIX 系统调用返回 -1 表示错误不同，POSIX 线程函数会在其结果中返回一个（POSIX 线程函数返回 0 表示成功）错误号（正数，类型为 errno 所专用）。使用方式：

```c
error = pthread_create(&thread, NULL, func, $arg);
if(error != 0){
    errExitEN(s, "pthread_create");
}
```

#### 诊断其他类型的错误

诊断其他类型的错误时，本书使用的是 `fatal()`、`usageErr()`以及 `cmdLineErr()`。

- 函数 `fatal()` 用来诊断一般性错误，其中包括未设置 errno 的库函数错误。除了将一个终止换行符自动追加到输出字符串尾部以外，`fatal()` 的参数列表与 `printf()` 基本相同。该函数会在标准错误上打印格式化输出，然后，像 `errExit()` 那样终止程序。
- 函数 `usageErr()` 用来诊断命令行参数使用方面的错误。其参数列表风格与 `printf()` 相同，并在 标准错误上打印字符串`“Usage：”`，随之以格式化输出，然后调用 `exit()` 终止程序。
- 函数 `cmdLineErr()` 酷似 `usageErr()`，但其错误诊断是针对于特定程序的命令行参数。

#### Linux 错误名

路径为 `lib/ename.c.inc`，该文件定义了一个名为 “ename” 的字符串数组，其内容是与 errno 的各种可能值相对应的符号名称。本书所采用的错误处理函数 会使用该数组，去打印与某个特定错误号相对应的符号名。之所以做如此变通，是为了应对以下两种实际情况：

- 一方面，`strerror()` 不会标识出与错误消息相对应的符号常量
- 另一方面，手册页在描述错误时，使用的是符号名称。打印出符号名便于读者在手册页中查找错误原因。

>由于 errno 值随 Linux 硬件架构的不同而有所变化，因此 ename.c.inc 文件的内容与特定的硬件架构相关。原书 ename.c.inc 文件版本专用于 Linux 2.6/x86-32 系统。 构建该文件的脚本 lib/Build_ename.sh，包含于为本书发布的源码当中。可以使用该脚本， 针对特定的硬件平台及内核版本，来构建 ename.c.inc 文件。

#### 解析数值型命令行参数的函数

在本书中频繁用于解析整形命令行参数： `getInt()` 和 `getLong()`。较之于 `atoi()`、`atol()` 以及 `strtol()`，它们的主要优点在于针对数值型参数提 供了一些基本的有效性检查。头文件路径为 `lib/get_num.h`

```c
long getLong(const char *arg, int flags, const char *name);

int getInt(const char *arg, int flags, const char *name);
```

- 函数 `getInt()` 和 `getLong()` 分别将 arg 指向的字符串转换为 int 或 long。如果 arg 未包含一个 有效的整数字符串（即仅包含数字以及字符 “+” 和 “-” ），那么这两个函数会打印一条错误消息，并终止程序。
- 若参数 name 非空，则所含内容应为一字符串，用于标识 arg 对应于命令行中相应参数的 名称。在上述两函数中，无论打印任何错误消息，该字符串都是消息中的一部分。
- 可通过 flags 参数对 `getInt()` 和 `getLong()` 函数的操作施加一些控制。默认情况下，两个函数会处理包含有符号十进制整数的字符串。若将定义于头文件中的一个或多个 `GN_*` 系列常量与 flags 相或，则既可以选择其他的转换进制，也能将数值范围限制为非负或正整数。
